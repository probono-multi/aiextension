"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var context_exports = {};
__export(context_exports, {
  Context: () => Context
});
module.exports = __toCommonJS(context_exports);
var import_browserContext = require("../browserContext");
var import_actionRunner = require("./actionRunner");
var import_codegen = require("./codegen");
class Context {
  constructor(apiCallProgress, page) {
    this.actions = [];
    this._progress = apiCallProgress;
    this.page = page;
    this.options = page.browserContext._options.agent;
    this.sdkLanguage = page.browserContext._browser.sdkLanguage();
  }
  async callTool(tool, params, options) {
    this._callIntent = options.intent;
    try {
      return await tool.handle(this, params);
    } finally {
      this._callIntent = void 0;
    }
  }
  async runActionAndWait(action) {
    return await this.runActionsAndWait([action]);
  }
  async runActionsAndWait(action) {
    const error = await this.waitForCompletion(async () => {
      for (const a of action) {
        await (0, import_actionRunner.runAction)(this._progress, "generate", this.page, a, this.options?.secrets ?? []);
        const code = await (0, import_codegen.generateCode)(this.sdkLanguage, a);
        this.actions.push({ ...a, code, intent: this._callIntent });
      }
      return void 0;
    }).catch((error2) => error2);
    return await this.snapshotResult(error);
  }
  async waitForCompletion(callback) {
    const requests = [];
    const requestListener = (request) => requests.push(request);
    const disposeListeners = () => {
      this.page.browserContext.off(import_browserContext.BrowserContext.Events.Request, requestListener);
    };
    this.page.browserContext.on(import_browserContext.BrowserContext.Events.Request, requestListener);
    let result;
    try {
      result = await callback();
      await this._progress.wait(500);
    } finally {
      disposeListeners();
    }
    const requestedNavigation = requests.some((request) => request.isNavigationRequest());
    if (requestedNavigation) {
      await this.page.mainFrame().waitForLoadState(this._progress, "load");
      return result;
    }
    const promises = [];
    for (const request of requests) {
      if (["document", "stylesheet", "script", "xhr", "fetch"].includes(request.resourceType()))
        promises.push(request.response().then((r) => r?.finished()));
      else
        promises.push(request.response());
    }
    await this._progress.race(promises, { timeout: 5e3 });
    if (requests.length)
      await this._progress.wait(500);
    return result;
  }
  async snapshotResult(error) {
    let { full } = await this.page.snapshotForAI(this._progress);
    full = this._redactText(full);
    const text = [];
    if (error)
      text.push(`# Error
${error.message}`);
    else
      text.push(`# Success`);
    text.push(`# Page snapshot
${full}`);
    return {
      _meta: {
        "dev.lowire/state": {
          "Page snapshot": full
        },
        "dev.lowire/history": error ? [{
          category: "error",
          content: error.message
        }] : []
      },
      isError: !!error,
      content: [{ type: "text", text: text.join("\n\n") }]
    };
  }
  async refSelectors(params) {
    return Promise.all(params.map(async (param) => {
      try {
        const { resolvedSelector } = await this.page.mainFrame().resolveSelector(this._progress, `aria-ref=${param.ref}`);
        return resolvedSelector;
      } catch (e) {
        throw new Error(`Ref ${param.ref} not found in the current page snapshot. Try capturing new snapshot.`);
      }
    }));
  }
  limits(options = {}) {
    return {
      maxTurns: options.maxTurns ?? this.options?.maxTurns ?? 10,
      maxTokens: options.maxTokens ?? this.options?.maxTokens ?? void 0
    };
  }
  _redactText(text) {
    const secrets = this.options?.secrets;
    if (!secrets)
      return text;
    const redactText = (text2) => {
      for (const { name, value } of secrets)
        text2 = text2.replaceAll(value, `<secret>${name}</secret>`);
      return text2;
    };
    return redactText(text);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Context
});
