"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var actionRunner_exports = {};
__export(actionRunner_exports, {
  generateActionTimeout: () => generateActionTimeout,
  performActionTimeout: () => performActionTimeout,
  runAction: () => runAction
});
module.exports = __toCommonJS(actionRunner_exports);
var import_expectUtils = require("../utils/expectUtils");
var import_time = require("../../utils/isomorphic/time");
var import_progress = require("../progress");
async function runAction(parentProgress, mode, page, action, secrets) {
  const timeout = mode === "generate" ? generateActionTimeout(action) : performActionTimeout(action);
  const mt = (0, import_time.monotonicTime)();
  const deadline = mt + timeout;
  const minDeadline = parentProgress.deadline ? Math.min(parentProgress.deadline, deadline) : deadline;
  const pc = new import_progress.ProgressController();
  return await pc.run(async (progress) => {
    return await innerRunAction(progress, page, action, secrets);
  }, minDeadline - mt);
}
async function innerRunAction(progress, page, action, secrets) {
  const frame = page.mainFrame();
  switch (action.method) {
    case "click":
      await frame.click(progress, action.selector, { ...action.options, ...strictTrue });
      break;
    case "drag":
      await frame.dragAndDrop(progress, action.sourceSelector, action.targetSelector, { ...strictTrue });
      break;
    case "hover":
      await frame.hover(progress, action.selector, { ...action.options, ...strictTrue });
      break;
    case "selectOption":
      await frame.selectOption(progress, action.selector, [], action.labels.map((a) => ({ label: a })), { ...strictTrue });
      break;
    case "pressKey":
      await page.keyboard.press(progress, action.key);
      break;
    case "pressSequentially": {
      const secret = secrets?.find((s) => s.name === action.text)?.value ?? action.text;
      await frame.type(progress, action.selector, secret, { ...strictTrue });
      if (action.submit)
        await page.keyboard.press(progress, "Enter");
      break;
    }
    case "fill": {
      const secret = secrets?.find((s) => s.name === action.text)?.value ?? action.text;
      await frame.fill(progress, action.selector, secret, { ...strictTrue });
      if (action.submit)
        await page.keyboard.press(progress, "Enter");
      break;
    }
    case "setChecked":
      if (action.checked)
        await frame.check(progress, action.selector, { ...strictTrue });
      else
        await frame.uncheck(progress, action.selector, { ...strictTrue });
      break;
    case "expectVisible": {
      const result = await frame.expect(progress, action.selector, { expression: "to.be.visible", isNot: false });
      if (result.errorMessage)
        throw new Error(result.errorMessage);
      break;
    }
    case "expectValue": {
      let result;
      if (action.type === "textbox" || action.type === "combobox" || action.type === "slider") {
        const expectedText = (0, import_expectUtils.serializeExpectedTextValues)([action.value]);
        result = await frame.expect(progress, action.selector, { expression: "to.have.value", expectedText, isNot: false });
      } else if (action.type === "checkbox" || action.type === "radio") {
        const expectedValue = { checked: action.value === "true" };
        result = await frame.expect(progress, action.selector, { selector: action.selector, expression: "to.be.checked", expectedValue, isNot: false });
      } else {
        throw new Error(`Unsupported element type: ${action.type}`);
      }
      if (!result.matches)
        throw new Error(result.errorMessage);
      break;
    }
  }
}
function generateActionTimeout(action) {
  switch (action.method) {
    case "click":
    case "drag":
    case "hover":
    case "selectOption":
    case "pressKey":
    case "pressSequentially":
    case "fill":
    case "setChecked":
      return 5e3;
    case "expectVisible":
    case "expectValue":
      return 1;
  }
}
function performActionTimeout(action) {
  switch (action.method) {
    case "click":
    case "drag":
    case "hover":
    case "selectOption":
    case "pressKey":
    case "pressSequentially":
    case "fill":
    case "setChecked":
      return 0;
    // no timeout
    case "expectVisible":
    case "expectValue":
      return 5e3;
  }
}
const strictTrue = { strict: true };
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  generateActionTimeout,
  performActionTimeout,
  runAction
});
