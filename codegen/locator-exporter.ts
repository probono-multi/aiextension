import fs from "fs";
import path from "path";
import type { RankedLocator } from "./locator-model";

export type ExportLanguage = "ts" | "py";
export type ExportFormat = "dictionary" | "class";

export interface ExporterOptions {
  language?: ExportLanguage;
  format?: ExportFormat;
  includeComments?: boolean;
}

function sortLocators(a: RankedLocator, b: RankedLocator) {
  const ra = a.rank ?? Number.NEGATIVE_INFINITY;
  const rb = b.rank ?? Number.NEGATIVE_INFINITY;
  if (ra !== rb) return rb - ra;
  if (a.stabilityScore !== b.stabilityScore) return b.stabilityScore - a.stabilityScore;
  const na = (a.name ?? a.value).toString();
  const nb = (b.name ?? b.value).toString();
  return na.localeCompare(nb);
}

function sanitizeToCamel(name: string) {
  return name
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .trim()
    .split(/\s+/)
    .filter(Boolean)
    .map((w, i) => (i === 0 ? w.toLowerCase() : w[0].toUpperCase() + w.slice(1)))
    .join("")
    .replace(/^[^a-zA-Z_]+/, "");
}

function sanitizeToSnake(name: string) {
  return name
    .replace(/[^a-zA-Z0-9]+/g, "_")
    .replace(/_{2,}/g, "_")
    .replace(/^_|_$/g, "")
    .toLowerCase()
    .replace(/^[^a-zA-Z]+/, "elem");
}

export function generateLocatorsFileContent(
  pageName: string,
  locators: RankedLocator[],
  opts: ExporterOptions = { language: "ts", format: "dictionary", includeComments: true }
) {
  const language = opts.language ?? "ts";
  const format = opts.format ?? "dictionary";
  const includeComments = opts.includeComments ?? true;

  const sorted = [...locators].sort(sortLocators);

  const used = new Map<string, number>();
  const entries: { key: string; locator: RankedLocator }[] = [];
  for (const l of sorted) {
    const baseRaw = l.name ?? l.value;
    const base = language === "py" ? sanitizeToSnake(String(baseRaw)) : sanitizeToCamel(String(baseRaw));
    let key = base || (language === "py" ? "element" : "element");
    if (used.has(key)) {
      const n = used.get(key)! + 1;
      used.set(key, n);
      key = `${key}${n}`;
    } else used.set(key, 1);
    entries.push({ key, locator: l });
  }

  if (language === "ts") {
    const lines: string[] = [];
    lines.push(`/**`);
    lines.push(` * Locators for ${pageName}`);
    lines.push(` * Generated by locator-exporter`);
    lines.push(` */`);
    if (format === "dictionary") {
      lines.push(`export const ${pageName}Locators = {`);
      for (const e of entries) {
        const l = e.locator;
        if (includeComments) {
          lines.push(
            `  // rank: ${l.rank ?? "n/a"}, stabilityScore: ${l.stabilityScore}, reason: ${JSON.stringify(
              l.reason ?? ""
            )}`
          );
        }
        lines.push(
          `  ${e.key}: { strategy: ${JSON.stringify(l.strategy)}, value: ${JSON.stringify(
            l.value
          )}, playwrightKind: ${JSON.stringify(l.playwrightKind)} },`
        );
      }
      lines.push(`} as const;`);
    } else {
      lines.push(`export class ${pageName}Locators {`);
      for (const e of entries) {
        const l = e.locator;
        if (includeComments) {
          lines.push(
            `  // rank: ${l.rank ?? "n/a"}, stabilityScore: ${l.stabilityScore}, reason: ${JSON.stringify(
              l.reason ?? ""
            )}`
          );
        }
        lines.push(
          `  static readonly ${e.key} = { strategy: ${JSON.stringify(l.strategy)}, value: ${JSON.stringify(
            l.value
          )}, playwrightKind: ${JSON.stringify(l.playwrightKind)} };`
        );
      }
      lines.push(`}`);
    }
    return lines.join("\n");
  } else {
    const lines: string[] = [];
    lines.push(`"""`);
    lines.push(`Locators for ${pageName}`);
    lines.push(`Generated by locator-exporter`);
    lines.push(`"""`);
    if (format === "dictionary") {
      const exportName = `${pageName.toUpperCase().replace(/[^A-Z0-9]+/g, "_")}_LOCATORS`;
      lines.push(``);
      lines.push(`${exportName} = {`);
      for (const e of entries) {
        const l = e.locator;
        if (includeComments) {
          lines.push(`  # rank: ${l.rank ?? "n/a"}, stabilityScore: ${l.stabilityScore}, reason: ${JSON.stringify(l.reason ?? "")}`);
        }
        lines.push(
          `  "${e.key}": {"strategy": ${JSON.stringify(l.strategy)}, "value": ${JSON.stringify(
            l.value
          )}, "playwrightKind": ${JSON.stringify(l.playwrightKind)}},`
        );
      }
      lines.push(`}`);
    } else {
      const className = `${pageName.replace(/[^a-zA-Z0-9]/g, "")}Locators`;
      lines.push(``);
      lines.push(`class ${className}:`);
      lines.push(`    # class-level locator attributes (only objects; no actions)`);
      for (const e of entries) {
        const l = e.locator;
        if (includeComments) {
          lines.push(`    # rank: ${l.rank ?? "n/a"}, stabilityScore: ${l.stabilityScore}, reason: ${JSON.stringify(l.reason ?? "")}`);
        }
        lines.push(`    ${e.key} = {"strategy": ${JSON.stringify(l.strategy)}, "value": ${JSON.stringify(l.value)}, "playwrightKind": ${JSON.stringify(l.playwrightKind)}}`);
      }
    }
    return lines.join("\n");
  }
}

export function writeLocatorsToFile(
  outFolder: string,
  pageName: string,
  locators: RankedLocator[],
  opts: ExporterOptions = { language: "ts", format: "dictionary", includeComments: true }
) {
  const content = generateLocatorsFileContent(pageName, locators, opts);
  if (!fs.existsSync(outFolder)) fs.mkdirSync(outFolder, { recursive: true });
  const ext = opts.language === "py" ? "py" : "ts";
  const filename = `${pageName}.${ext}`;
  const filePath = path.join(outFolder, filename);
  fs.writeFileSync(filePath, content, { encoding: "utf8" });
  return filePath;
}